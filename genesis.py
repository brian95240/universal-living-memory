import psutil
import platform
import os
import json
import torch
import subprocess
from pathlib import Path
from typing import Optional, Dict

# --- CONSTANTS ---
PROJECT_ROOT = Path(__file__).parent.resolve()
TARGET_VOLUME_LABEL = "Seagate"
FALLBACK_STORAGE = PROJECT_ROOT / "local_storage"
PROVIDERS_CONFIG = PROJECT_ROOT / "config" / "providers.json"

def get_system_specs() -> Dict:
    specs = {
        "os": platform.system(),
        "arch": platform.machine(),
        "hostname": platform.node(),
        "cpu_cores_physical": psutil.cpu_count(logical=False),
        "ram_gb": round(psutil.virtual_memory().total / (1024**3), 2),
        "gpu": {"count": 0, "name": "None", "vram_gb": 0.0}
    }
    if torch.cuda.is_available():
        props = torch.cuda.get_device_properties(0)
        specs["gpu"] = {
            "count": torch.cuda.device_count(),
            "name": props.name,
            "vram_gb": round(props.total_memory / (1024**3), 2)
        }
    return specs

def find_volume_by_label(label: str) -> Optional[str]:
    for partition in psutil.disk_partitions():
        try:
            mount = partition.mountpoint
            if platform.system() == "Windows":
                result = subprocess.run(
                    ["powershell", "-Command", f"(Get-Volume -DriveLetter {mount[0]}).FileSystemLabel"],
                    capture_output=True, text=True
                )
                if result.returncode == 0 and label.lower() in result.stdout.strip().lower():
                    return mount.rstrip("\\")
            else:
                result = subprocess.run(["lsblk", "-no", "LABEL", mount], capture_output=True, text=True)
                if result.returncode == 0 and label.lower() in result.stdout.strip().lower():
                    return mount
        except:
            continue
    return None

def calculate_resource_limits(specs: Dict) -> Dict:
    ram_gb = specs["ram_gb"]
    available_ram_mb = int(ram_gb * 1024 * 0.65)
    db_limit_mb = min(max(512, int(available_ram_mb * 0.3)), 4096)
    worker_threads = max(2, specs["cpu_cores_physical"] - 2)
    return {
        "DB_MEM_LIMIT": f"{db_limit_mb}m",
        "AI_WORKER_THREADS": worker_threads
    }

def generate_env(specs: Dict, storage_path: str, limits: Dict):
    env_content = f"""# AUTO-GENERATED BY GENESIS v2
PROJECT_ROOT={PROJECT_ROOT}
EXTERNAL_STORAGE_PATH={storage_path}
HOST_OS={specs['os']}
DB_MEM_LIMIT={limits['DB_MEM_LIMIT']}
AI_WORKER_THREADS={limits['AI_WORKER_THREADS']}
"""
    (PROJECT_ROOT / ".env").write_text(env_content)
    print(f"[âœ“] .env generated. Storage: {storage_path}")

def init_config():
    if not PROVIDERS_CONFIG.exists():
        (PROJECT_ROOT / "config").mkdir(exist_ok=True)
        template = {"providers": {"grok": {"enabled": False, "api_key_env": "GROK_API_KEY"}}}
        PROVIDERS_CONFIG.write_text(json.dumps(template, indent=4))

if __name__ == "__main__":
    print("[GENESIS] Initializing Hardware Discovery...")
    specs = get_system_specs()
    storage = find_volume_by_label(TARGET_VOLUME_LABEL)
    if not storage:
        storage = str(FALLBACK_STORAGE)
        FALLBACK_STORAGE.mkdir(exist_ok=True)
    generate_env(specs, storage, calculate_resource_limits(specs))
    init_config()
